//#include<stdint.h>

/*
动态规划（线性规划、dp）：
	1 把一个问题分解成若干个子问题
	2 将中间结果存储以免重复计算
基本步骤：
	1 找出最优解的性质，然后刻画结构特征（找规律）
	2 找最优解（找最好的解决方案） 循环或者递归找
	3 以自上而下或者自下而上的方式来计算局部最优解
	4 通过最优值来构造最优解
主要解决的问题：
	1 走台阶问题
		有N个台阶，走法：两种
			1 一次走一个台阶
			2 一次走两个台阶
			问：走N个台阶有多少种走法
		N为1：两种
			1或2
		N为2：三种
			1 1或2 或1 2
		N为3：五种
			1 1 1或1 2或2 1或2 2或1 1 2

	2 兔子问题
		一对兔子 从第三个月开始生一对兔子，第N个月有多少兔子

	3 求最短路径问题
		有矩阵：走法只有两种：往下或者往右，求最短路径
				一	二	三	四	五
			一	0	0	0	0	0
			二	0	3	6	2	1
			三	0	4	3	0	6
			四	0	5	5	4	3
			五	0	9	7	2	8
			
			从二 二 开始，遍历一遍整个数组，记录最短路径值
			遍历到右下角那个点，最短路径也就出来了

	4 求最大上升串长度问题
	字符串中字符 上升
	1 4 7 2 5 8 3 6 9
		1 2 3 6 9
		1 4 7 8 9
		1 4 5 6 9
		1 4 5 8 9
	依次找每个字符之前的最长（上升串）的长度

	5 求最大路径和问题


	6  背包问题
		有N种物品
		价值 体积 怎么样
		一个容量为V的背包 最大价值是？

	7 最小生成树问题
		kruskal算法：贪心算法思想
			边长按值排序 然后从小到大添加到最小生成树中 有回环的舍弃
		prim算法：动态规划思想
			两个集合，一个个顶点加入进来
			（候选边中挑值小的）
			集合里已经有的就不用重复添加


动态规划和贪心算法的异同：
	相同点：
		都是要找最优子结构性质（局部最优解）
	不同点：
		动态规划算法中，每步所做的选择依赖于相关子问题的解，因而只有解出相关子问题，才能做出选择
		贪心算法则是只在当前状态下做最好的选择（局部最优解），然后再去解出做这个选择后产生的相应子问题

	贪心：每一步的最优解包含上一步的最优解，上一步之前的最优解不保留

	dp：全局最优解中一定包含某个局部最优解，但不一定包含上一步（上一个局部最优解），因此要记录之前所有的局部最优解

*/

//int main() {
//
//
//	return 0;
//}
